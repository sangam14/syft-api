<template>
  <div class="vulnerability-trend">
    <div class="chart-header">
      <h3>Vulnerability Trends</h3>
      <div class="chart-filters">
        <select v-model="selectedTimeframe" class="modern-input">
          <option value="7">Last 7 Days</option>
          <option value="30">Last 30 Days</option>
          <option value="90">Last 90 Days</option>
          <option value="365">Last Year</option>
        </select>
        <select v-model="selectedSeverity" class="modern-input">
          <option value="all">All Severities</option>
          <option value="critical">Critical</option>
          <option value="high">High</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
        </select>
      </div>
    </div>
    <div class="chart-container">
      <canvas ref="chartCanvas"></canvas>
    </div>
    <div class="chart-summary">
      <div class="summary-item">
        <span class="summary-label">Total Vulnerabilities</span>
        <span class="summary-value">{{ totalVulnerabilities }}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Fixed</span>
        <span class="summary-value">{{ fixedVulnerabilities }}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">New</span>
        <span class="summary-value">{{ newVulnerabilities }}</span>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, watch, computed } from 'vue';
// We're removing the Chart.js import and using the CDN version

export default {
  name: 'VulnerabilityTrend',
  props: {
    sbomData: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const chartCanvas = ref(null);
    const chart = ref(null);
    const selectedTimeframe = ref('30');
    const selectedSeverity = ref('all');

    const vulnerabilityData = computed(() => {
      if (!props.sbomData || !props.sbomData.components) {
        return [];
      }

      const days = parseInt(selectedTimeframe.value);
      const data = [];

      for (let i = 0; i < days; i++) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];

        data.push({
          date: dateStr,
          count: Math.floor(Math.random() * 10), // Placeholder - replace with actual data
          severity: ['critical', 'high', 'medium', 'low'][Math.floor(Math.random() * 4)]
        });
      }

      return data;
    });

    const totalVulnerabilities = computed(() => {
      return vulnerabilityData.value.reduce((sum, item) => sum + item.count, 0);
    });

    const fixedVulnerabilities = computed(() => {
      return Math.floor(totalVulnerabilities.value * 0.3); // Placeholder - replace with actual data
    });

    const newVulnerabilities = computed(() => {
      return Math.floor(totalVulnerabilities.value * 0.1); // Placeholder - replace with actual data
    });

    const createChart = () => {
      if (chart.value) {
        chart.value.destroy();
      }

      if (!window.Chart) {
        console.error('Chart.js not loaded');
        return;
      }

      const ctx = chartCanvas.value.getContext('2d');
      const filteredData = vulnerabilityData.value.filter(item => 
        selectedSeverity.value === 'all' || item.severity === selectedSeverity.value
      );

      chart.value = new window.Chart(ctx, {
        type: 'line',
        data: {
          labels: filteredData.map(item => item.date),
          datasets: [{
            label: 'Vulnerabilities',
            data: filteredData.map(item => item.count),
            borderColor: '#2563eb',
            backgroundColor: 'rgba(37, 99, 235, 0.1)',
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                stepSize: 1
              }
            }
          }
        }
      });
    };

    // Load Chart.js from CDN
    const loadChartJs = () => {
      return new Promise((resolve) => {
        if (window.Chart) {
          resolve();
          return;
        }

        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
        script.onload = () => resolve();
        document.head.appendChild(script);
      });
    };

    watch([selectedTimeframe, selectedSeverity], () => {
      if (window.Chart) {
        createChart();
      }
    });

    onMounted(async () => {
      await loadChartJs();
      createChart();
    });

    return {
      chartCanvas,
      selectedTimeframe,
      selectedSeverity,
      totalVulnerabilities,
      fixedVulnerabilities,
      newVulnerabilities
    };
  }
};
</script>

<style scoped>
.vulnerability-trend {
  background: white;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: var(--card-shadow);
}

.chart-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
}

.chart-filters {
  display: flex;
  gap: 1rem;
}

.chart-container {
  height: 300px;
  margin-bottom: 1.5rem;
}

.chart-summary {
  display: flex;
  justify-content: space-around;
  padding: 1rem;
  background: var(--light-color);
  border-radius: 8px;
}

.summary-item {
  text-align: center;
}

.summary-label {
  display: block;
  font-size: var(--font-size-sm);
  color: var(--secondary-color);
  margin-bottom: 0.5rem;
}

.summary-value {
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-semibold);
  color: var(--dark-color);
}
</style> 