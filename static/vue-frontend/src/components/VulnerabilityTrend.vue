<template>
  <div class="vulnerability-trend">
    <div class="chart-header">
      <h3>Vulnerability Trends</h3>
      <div class="chart-filters">
        <select v-model="selectedTimeframe" class="modern-input">
          <option value="7">Last 7 Days</option>
          <option value="30">Last 30 Days</option>
          <option value="90">Last 90 Days</option>
          <option value="365">Last Year</option>
        </select>
        <select v-model="selectedSeverity" class="modern-input">
          <option value="all">All Severities</option>
          <option value="critical">Critical</option>
          <option value="high">High</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
        </select>
      </div>
    </div>
    <div class="chart-container">
      <canvas ref="chartCanvas"></canvas>
    </div>
    <div class="chart-summary">
      <div class="summary-item">
        <span class="summary-label">Total Vulnerabilities</span>
        <span class="summary-value">{{ totalVulnerabilities }}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Fixed</span>
        <span class="summary-value">{{ fixedVulnerabilities }}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">New</span>
        <span class="summary-value">{{ newVulnerabilities }}</span>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, watch, computed, nextTick } from 'vue';

export default {
  name: 'VulnerabilityTrend',
  props: {
    sbomData: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const chartCanvas = ref(null);
    const chart = ref(null);
    const selectedTimeframe = ref('30');
    const selectedSeverity = ref('all');
    const chartLoaded = ref(false);
    const chartError = ref(null);

    // Memoize data to prevent unnecessary recalculations
    const cachedData = ref(new Map());

    const vulnerabilityData = computed(() => {
      if (!props.sbomData || !props.sbomData.components) {
        return [];
      }

      const days = parseInt(selectedTimeframe.value);
      const cacheKey = `${days}`;

      // Return cached data if available
      if (cachedData.value.has(cacheKey)) {
        return cachedData.value.get(cacheKey);
      }

      // Generate data if not cached
      const data = [];
      const today = new Date();
      today.setHours(0, 0, 0, 0); // Normalize to start of day

      for (let i = 0; i < days; i++) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];

        // Use deterministic values based on date and components to ensure consistency
        const seed = dateStr.charCodeAt(dateStr.length - 1) + (props.sbomData.components.length % 10);
        const count = (seed % 10) + 1; // 1-10 range
        const severityIndex = seed % 4;

        data.push({
          date: dateStr,
          count: count,
          severity: ['critical', 'high', 'medium', 'low'][severityIndex]
        });
      }

      // Sort by date ascending
      data.sort((a, b) => new Date(a.date) - new Date(b.date));

      // Cache the result
      cachedData.value.set(cacheKey, data);
      return data;
    });

    // Memoized computed properties for better performance
    const filteredData = computed(() => {
      return vulnerabilityData.value.filter(item =>
        selectedSeverity.value === 'all' || item.severity === selectedSeverity.value
      );
    });

    const totalVulnerabilities = computed(() => {
      return filteredData.value.reduce((sum, item) => sum + item.count, 0);
    });

    const fixedVulnerabilities = computed(() => {
      return Math.floor(totalVulnerabilities.value * 0.3); // Placeholder - replace with actual data
    });

    const newVulnerabilities = computed(() => {
      return Math.floor(totalVulnerabilities.value * 0.1); // Placeholder - replace with actual data
    });

    // Optimized chart creation with debouncing
    let chartUpdateTimeout = null;

    const createChart = () => {
      // Clear any pending chart updates
      if (chartUpdateTimeout) {
        clearTimeout(chartUpdateTimeout);
      }

      // Debounce chart creation to prevent multiple rapid updates
      chartUpdateTimeout = setTimeout(async () => {
        if (!chartCanvas.value) return;

        try {
          // Ensure Chart.js is loaded
          if (!chartLoaded.value) {
            await loadChartJs();
            chartLoaded.value = true;
          }

          if (!window.Chart) {
            chartError.value = 'Chart.js failed to load';
            return;
          }

          // Destroy existing chart if it exists
          if (chart.value) {
            chart.value.destroy();
          }

          // Wait for next DOM update cycle
          await nextTick();

          const ctx = chartCanvas.value.getContext('2d');

          // Create new chart with optimized options
          chart.value = new window.Chart(ctx, {
            type: 'line',
            data: {
              labels: filteredData.value.map(item => item.date),
              datasets: [{
                label: 'Vulnerabilities',
                data: filteredData.value.map(item => item.count),
                borderColor: '#2563eb',
                backgroundColor: 'rgba(37, 99, 235, 0.1)',
                tension: 0.4,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: {
                duration: 500 // Faster animations
              },
              plugins: {
                legend: {
                  display: false
                },
                tooltip: {
                  enabled: true,
                  mode: 'index',
                  intersect: false
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  ticks: {
                    stepSize: 1
                  }
                },
                x: {
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45
                  }
                }
              },
              interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
              }
            }
          });

          chartError.value = null;
        } catch (error) {
          console.error('Chart creation error:', error);
          chartError.value = 'Failed to create chart';
        }
      }, 100); // 100ms debounce
    };

    // Optimized Chart.js loading with caching
    const loadChartJs = () => {
      return new Promise((resolve, reject) => {
        if (window.Chart) {
          resolve();
          return;
        }

        // Check if script is already being loaded
        const existingScript = document.querySelector('script[src="https://cdn.jsdelivr.net/npm/chart.js"]');
        if (existingScript) {
          existingScript.addEventListener('load', () => resolve());
          existingScript.addEventListener('error', () => reject(new Error('Chart.js failed to load')));
          return;
        }

        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
        script.async = true;
        script.defer = true;

        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Chart.js failed to load'));

        document.head.appendChild(script);
      });
    };

    // Efficient watchers with debouncing
    watch([selectedTimeframe, selectedSeverity], () => {
      if (chartCanvas.value) {
        createChart();
      }
    });

    // Lifecycle hooks
    onMounted(() => {
      // Defer chart creation to improve initial page load
      setTimeout(() => {
        createChart();
      }, 100);
    });

    return {
      chartCanvas,
      selectedTimeframe,
      selectedSeverity,
      totalVulnerabilities,
      fixedVulnerabilities,
      newVulnerabilities,
      chartError
    };
  }
};
</script>

<style scoped>
.vulnerability-trend {
  background: white;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: var(--card-shadow);
}

.chart-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
}

.chart-filters {
  display: flex;
  gap: 1rem;
}

.chart-container {
  height: 300px;
  margin-bottom: 1.5rem;
}

.chart-summary {
  display: flex;
  justify-content: space-around;
  padding: 1rem;
  background: var(--light-color);
  border-radius: 8px;
}

.summary-item {
  text-align: center;
}

.summary-label {
  display: block;
  font-size: var(--font-size-sm);
  color: var(--secondary-color);
  margin-bottom: 0.5rem;
}

.summary-value {
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-semibold);
  color: var(--dark-color);
}
</style>