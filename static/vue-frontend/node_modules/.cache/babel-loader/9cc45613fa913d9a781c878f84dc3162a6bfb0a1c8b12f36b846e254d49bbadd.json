{"ast":null,"code":"/**\n * Asset Loader Utility\n * \n * This utility provides functions to preload and manage external assets like\n * scripts, stylesheets, and images to improve application performance.\n */\n\n// Track loaded assets to prevent duplicate loading\nconst loadedAssets = new Map();\n\n/**\n * Preload a script with optimized loading strategy\n * \n * @param {string} src - Script URL to load\n * @param {Object} options - Loading options\n * @param {boolean} options.async - Whether to load the script asynchronously\n * @param {boolean} options.defer - Whether to defer script loading\n * @param {string} options.integrity - Integrity hash for the script\n * @param {Function} options.onLoad - Callback function when script loads\n * @returns {Promise} - Promise that resolves when the script is loaded\n */\nexport function preloadScript(src, options = {}) {\n  const {\n    async = true,\n    defer = true,\n    integrity = '',\n    onLoad = null\n  } = options;\n\n  // Return existing promise if script is already loading\n  if (loadedAssets.has(src)) {\n    return loadedAssets.get(src);\n  }\n  const loadPromise = new Promise((resolve, reject) => {\n    // Check if script is already in the document\n    const existingScript = document.querySelector(`script[src=\"${src}\"]`);\n    if (existingScript) {\n      resolve();\n      return;\n    }\n\n    // Create and configure script element\n    const script = document.createElement('script');\n    script.src = src;\n    script.async = async;\n    script.defer = defer;\n    if (integrity) {\n      script.integrity = integrity;\n      script.crossOrigin = 'anonymous';\n    }\n\n    // Set up event handlers\n    script.onload = () => {\n      if (onLoad && typeof onLoad === 'function') {\n        onLoad();\n      }\n      resolve();\n    };\n    script.onerror = error => {\n      loadedAssets.delete(src);\n      reject(new Error(`Failed to load script: ${src}`));\n    };\n\n    // Add script to document\n    document.head.appendChild(script);\n  });\n\n  // Store promise in cache\n  loadedAssets.set(src, loadPromise);\n  return loadPromise;\n}\n\n/**\n * Preload a stylesheet with optimized loading strategy\n * \n * @param {string} href - Stylesheet URL to load\n * @param {Object} options - Loading options\n * @param {string} options.media - Media attribute for the stylesheet\n * @param {string} options.integrity - Integrity hash for the stylesheet\n * @returns {Promise} - Promise that resolves when the stylesheet is loaded\n */\nexport function preloadStylesheet(href, options = {}) {\n  const {\n    media = 'all',\n    integrity = ''\n  } = options;\n\n  // Return existing promise if stylesheet is already loading\n  if (loadedAssets.has(href)) {\n    return loadedAssets.get(href);\n  }\n  const loadPromise = new Promise((resolve, reject) => {\n    // Check if stylesheet is already in the document\n    const existingLink = document.querySelector(`link[href=\"${href}\"]`);\n    if (existingLink) {\n      resolve();\n      return;\n    }\n\n    // Create and configure link element\n    const link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.href = href;\n    link.media = media;\n    if (integrity) {\n      link.integrity = integrity;\n      link.crossOrigin = 'anonymous';\n    }\n\n    // Set up event handlers\n    link.onload = () => resolve();\n    link.onerror = () => {\n      loadedAssets.delete(href);\n      reject(new Error(`Failed to load stylesheet: ${href}`));\n    };\n\n    // Add link to document\n    document.head.appendChild(link);\n  });\n\n  // Store promise in cache\n  loadedAssets.set(href, loadPromise);\n  return loadPromise;\n}\n\n/**\n * Preload an image to cache it for later use\n * \n * @param {string} src - Image URL to preload\n * @returns {Promise} - Promise that resolves when the image is loaded\n */\nexport function preloadImage(src) {\n  // Return existing promise if image is already loading\n  if (loadedAssets.has(src)) {\n    return loadedAssets.get(src);\n  }\n  const loadPromise = new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = () => {\n      loadedAssets.delete(src);\n      reject(new Error(`Failed to load image: ${src}`));\n    };\n    img.src = src;\n  });\n\n  // Store promise in cache\n  loadedAssets.set(src, loadPromise);\n  return loadPromise;\n}\n\n/**\n * Preload multiple assets in parallel\n * \n * @param {Array} assets - Array of asset objects to preload\n * @returns {Promise} - Promise that resolves when all assets are loaded\n */\nexport function preloadAssets(assets) {\n  const promises = assets.map(asset => {\n    switch (asset.type) {\n      case 'script':\n        return preloadScript(asset.src, asset.options);\n      case 'stylesheet':\n        return preloadStylesheet(asset.href, asset.options);\n      case 'image':\n        return preloadImage(asset.src);\n      default:\n        return Promise.reject(new Error(`Unknown asset type: ${asset.type}`));\n    }\n  });\n  return Promise.all(promises);\n}\n\n/**\n * Check if an asset is already loaded\n * \n * @param {string} src - Asset URL to check\n * @returns {boolean} - Whether the asset is loaded\n */\nexport function isAssetLoaded(src) {\n  return loadedAssets.has(src) && loadedAssets.get(src).status === 'fulfilled';\n}\n\n/**\n * Clear the asset cache\n */\nexport function clearAssetCache() {\n  loadedAssets.clear();\n}\nexport default {\n  preloadScript,\n  preloadStylesheet,\n  preloadImage,\n  preloadAssets,\n  isAssetLoaded,\n  clearAssetCache\n};","map":{"version":3,"names":["loadedAssets","Map","preloadScript","src","options","async","defer","integrity","onLoad","has","get","loadPromise","Promise","resolve","reject","existingScript","document","querySelector","script","createElement","crossOrigin","onload","onerror","error","delete","Error","head","appendChild","set","preloadStylesheet","href","media","existingLink","link","rel","preloadImage","img","Image","preloadAssets","assets","promises","map","asset","type","all","isAssetLoaded","status","clearAssetCache","clear"],"sources":["/Users/sangambiradar/Documents/syft-api/static/vue-frontend/src/utils/assetLoader.js"],"sourcesContent":["/**\n * Asset Loader Utility\n * \n * This utility provides functions to preload and manage external assets like\n * scripts, stylesheets, and images to improve application performance.\n */\n\n// Track loaded assets to prevent duplicate loading\nconst loadedAssets = new Map();\n\n/**\n * Preload a script with optimized loading strategy\n * \n * @param {string} src - Script URL to load\n * @param {Object} options - Loading options\n * @param {boolean} options.async - Whether to load the script asynchronously\n * @param {boolean} options.defer - Whether to defer script loading\n * @param {string} options.integrity - Integrity hash for the script\n * @param {Function} options.onLoad - Callback function when script loads\n * @returns {Promise} - Promise that resolves when the script is loaded\n */\nexport function preloadScript(src, options = {}) {\n  const {\n    async = true,\n    defer = true,\n    integrity = '',\n    onLoad = null\n  } = options;\n\n  // Return existing promise if script is already loading\n  if (loadedAssets.has(src)) {\n    return loadedAssets.get(src);\n  }\n\n  const loadPromise = new Promise((resolve, reject) => {\n    // Check if script is already in the document\n    const existingScript = document.querySelector(`script[src=\"${src}\"]`);\n    if (existingScript) {\n      resolve();\n      return;\n    }\n\n    // Create and configure script element\n    const script = document.createElement('script');\n    script.src = src;\n    script.async = async;\n    script.defer = defer;\n    \n    if (integrity) {\n      script.integrity = integrity;\n      script.crossOrigin = 'anonymous';\n    }\n\n    // Set up event handlers\n    script.onload = () => {\n      if (onLoad && typeof onLoad === 'function') {\n        onLoad();\n      }\n      resolve();\n    };\n    \n    script.onerror = (error) => {\n      loadedAssets.delete(src);\n      reject(new Error(`Failed to load script: ${src}`));\n    };\n\n    // Add script to document\n    document.head.appendChild(script);\n  });\n\n  // Store promise in cache\n  loadedAssets.set(src, loadPromise);\n  return loadPromise;\n}\n\n/**\n * Preload a stylesheet with optimized loading strategy\n * \n * @param {string} href - Stylesheet URL to load\n * @param {Object} options - Loading options\n * @param {string} options.media - Media attribute for the stylesheet\n * @param {string} options.integrity - Integrity hash for the stylesheet\n * @returns {Promise} - Promise that resolves when the stylesheet is loaded\n */\nexport function preloadStylesheet(href, options = {}) {\n  const {\n    media = 'all',\n    integrity = ''\n  } = options;\n\n  // Return existing promise if stylesheet is already loading\n  if (loadedAssets.has(href)) {\n    return loadedAssets.get(href);\n  }\n\n  const loadPromise = new Promise((resolve, reject) => {\n    // Check if stylesheet is already in the document\n    const existingLink = document.querySelector(`link[href=\"${href}\"]`);\n    if (existingLink) {\n      resolve();\n      return;\n    }\n\n    // Create and configure link element\n    const link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.href = href;\n    link.media = media;\n    \n    if (integrity) {\n      link.integrity = integrity;\n      link.crossOrigin = 'anonymous';\n    }\n\n    // Set up event handlers\n    link.onload = () => resolve();\n    link.onerror = () => {\n      loadedAssets.delete(href);\n      reject(new Error(`Failed to load stylesheet: ${href}`));\n    };\n\n    // Add link to document\n    document.head.appendChild(link);\n  });\n\n  // Store promise in cache\n  loadedAssets.set(href, loadPromise);\n  return loadPromise;\n}\n\n/**\n * Preload an image to cache it for later use\n * \n * @param {string} src - Image URL to preload\n * @returns {Promise} - Promise that resolves when the image is loaded\n */\nexport function preloadImage(src) {\n  // Return existing promise if image is already loading\n  if (loadedAssets.has(src)) {\n    return loadedAssets.get(src);\n  }\n\n  const loadPromise = new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = () => {\n      loadedAssets.delete(src);\n      reject(new Error(`Failed to load image: ${src}`));\n    };\n    img.src = src;\n  });\n\n  // Store promise in cache\n  loadedAssets.set(src, loadPromise);\n  return loadPromise;\n}\n\n/**\n * Preload multiple assets in parallel\n * \n * @param {Array} assets - Array of asset objects to preload\n * @returns {Promise} - Promise that resolves when all assets are loaded\n */\nexport function preloadAssets(assets) {\n  const promises = assets.map(asset => {\n    switch (asset.type) {\n      case 'script':\n        return preloadScript(asset.src, asset.options);\n      case 'stylesheet':\n        return preloadStylesheet(asset.href, asset.options);\n      case 'image':\n        return preloadImage(asset.src);\n      default:\n        return Promise.reject(new Error(`Unknown asset type: ${asset.type}`));\n    }\n  });\n\n  return Promise.all(promises);\n}\n\n/**\n * Check if an asset is already loaded\n * \n * @param {string} src - Asset URL to check\n * @returns {boolean} - Whether the asset is loaded\n */\nexport function isAssetLoaded(src) {\n  return loadedAssets.has(src) && loadedAssets.get(src).status === 'fulfilled';\n}\n\n/**\n * Clear the asset cache\n */\nexport function clearAssetCache() {\n  loadedAssets.clear();\n}\n\nexport default {\n  preloadScript,\n  preloadStylesheet,\n  preloadImage,\n  preloadAssets,\n  isAssetLoaded,\n  clearAssetCache\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}